Responses
Response content type

application/json
Curl

curl -X 'POST' \
  'https://uploader.nativespeak.app/login' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "email": "saideomarsaide@gmail.com",
  "password": "Damasco12"
}'
Request URL
https://uploader.nativespeak.app/login
Server response
Code	Details
200	
Response body
Download
{
  "message": "Logged in successfully",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoyLCJlbWFpbCI6InNhaWRlb21hcnNhaWRlQGdtYWlsLmNvbSIsImlzcyI6ImZvcmdlLXVwbG9hZGVyIiwiZXhwIjoxNzY1Nzk2NTQzLCJpYXQiOjE3NjU3MTAxNDN9.jJ3RTd-EaUEctbqL8EYr3cFWo_rjMqk7mRKEyuBzufw",
  "user": {
    "ID": 2,
    "Email": "saideomarsaide@gmail.com",
    "Password": "",
    "ForgeAPIKey": "0c6f4fd0-07a2-4045-bba5-83334ac95ab2",
    "CreatedAt": "2025-12-14T08:39:27.421934Z",
    "Projects": null
  },
  "forge_api_key": "0c6f4fd0-07a2-4045-bba5-83334ac95ab2"
}
Response headers
 access-control-allow-headers: Accept,Content-Type,Content-Length,Accept-Encoding,X-CSRF-Token,Authorization 
 access-control-allow-methods: POST,GET,OPTIONS,PUT,DELETE 
 access-control-allow-origin: * 
 alt-svc: h3=":443"; ma=2592000 
 content-length: 500 
 content-type: application/json 
 date: Sun,14 Dec 2025 11:02:23 GMT 
 vary: Accept-Encoding 


 Perfeito! ‚úÖ Login funcionando corretamente!

## üîë Informa√ß√µes da sua conta

| Campo | Valor |
|-------|-------|
| **User ID** | 2 |
| **Email** | saideomarsaide@gmail.com |
| **API Key** | `0c6f4fd0-07a2-4045-bba5-83334ac95ab2` |
| **JWT Token** | V√°lido por 24h (expira: 2025-12-15 11:02) |
| **Conta criada** | 14 de dezembro de 2025, 08:39 UTC |

## üéØ Como usar os tokens

### Op√ß√£o 1: API Key (recomendado para longo prazo)
```bash
curl 'https://uploader.nativespeak.app/api/projects' \
  -H 'Authorization: 0c6f4fd0-07a2-4045-bba5-83334ac95ab2'
```

### Op√ß√£o 2: JWT Token (expira em 24h)
```bash
curl 'https://uploader.nativespeak.app/api/projects' \
  -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
```

## üîß Pequena melhoria (opcional)

Notei que `Projects` est√° retornando `null`. Para manter consist√™ncia com os outros endpoints, vou melhorar:Agora, ap√≥s aplicar essa melhoria, a resposta do login ser√°:

```json
{
  "message": "Logged in successfully",
  "token": "eyJhbGci...",
  "user": {
    "ID": 2,
    "Email": "saideomarsaide@gmail.com",
    "Password": "",
    "ForgeAPIKey": "0c6f4fd0-07a2-4045-bba5-83334ac95ab2",
    "CreatedAt": "2025-12-14T08:39:27.421934Z",
    "Projects": []  // ‚Üê Array vazio em vez de null
  },
  "forge_api_key": "0c6f4fd0-07a2-4045-bba5-83334ac95ab2"
}
```

## üìä Resumo da sua sess√£o

Voc√™ est√° autenticado e pode usar:

### 1Ô∏è‚É£ **API Key permanente**
```
0c6f4fd0-07a2-4045-bba5-83334ac95ab2
```
- ‚úÖ Nunca expira
- ‚úÖ Use em scripts, apps, integra√ß√µes
- ‚ö†Ô∏è Pode ser rotacionada quando necess√°rio

### 2Ô∏è‚É£ **JWT Token tempor√°rio** (24h)
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoyLCJlbWFpbCI6InNhaWRlb21hcnNhaWRlQGdtYWlsLmNvbSIsImlzcyI6ImZvcmdlLXVwbG9hZGVyIiwiZXhwIjoxNzY1Nzk2NTQzLCJpYXQiOjE3NjU3MTAxNDN9.jJ3RTd-EaUEctbqL8EYr3cFWo_rjMqk7mRKEyuBzufw
```
- ‚úÖ Use em aplica√ß√µes web/mobile
- ‚è∞ Expira em 24h (renov√°vel com novo login)

### 3Ô∏è‚É£ **Seus projetos**
- **docph** - 2 arquivos (~6 MB)
- **photo** - vazio
- **photod** - vazio

Tudo funcionando perfeitamente! üöÄ

package handlers

import (
	"encoding/json"
	"net/http"

	"gorm.io/gorm"
	"github.com/GoogleCloudPlatform/golang-samples/run/helloworld/models"
	"github.com/GoogleCloudPlatform/golang-samples/run/helloworld/util"
)

type AuthRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type AuthResponse struct {
	Message     string       `json:"message"`
	Token       string       `json:"token,omitempty"`
	User        *models.User `json:"user,omitempty"`
	ForgeAPIKey string       `json:"forge_api_key,omitempty"`
}

// RegisterHandler godoc
// @Summary Register a new user
// @Description Creates a new user account and returns the user info along with an API key.
// @Tags auth
// @Accept  json
// @Produce  json
// @Param   auth_request  body  AuthRequest  true  "User registration details"
// @Success 201 {object} AuthResponse "User created successfully"
// @Failure 400 {string} string "Invalid request body or missing fields"
// @Failure 500 {string} string "Could not create user"
// @Router /register [post]
func RegisterHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		var req AuthRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		// Valida√ß√£o b√°sica
		if req.Email == "" || req.Password == "" {
			http.Error(w, "Email and password are required", http.StatusBadRequest)
			return
		}

		user := &models.User{
			Email:    req.Email,
			Password: req.Password,
		}

		// O hook BeforeCreate ir√° gerar a API key e hashear a senha
		if err := db.Create(user).Error; err != nil {
			http.Error(w, "Could not create user: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// N√£o retornar a senha e inicializar Projects como array vazio
		user.Password = ""
		if user.Projects == nil {
			user.Projects = make([]models.Project, 0)
		}

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(AuthResponse{
			Message:     "User created successfully",
			User:        user,
			ForgeAPIKey: user.ForgeAPIKey,
		})
	}
}

// LoginHandler godoc
// @Summary Log in a user
// @Description Authenticates a user and returns a JWT token.
// @Tags auth
// @Accept  json
// @Produce  json
// @Param   auth_request  body  AuthRequest  true  "User login credentials"
// @Success 200 {object} AuthResponse "Logged in successfully"
// @Failure 400 {string} string "Invalid request body"
// @Failure 401 {string} string "Invalid credentials"
// @Failure 500 {string} string "Could not generate token"
// @Router /login [post]
func LoginHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		var req AuthRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		var user models.User
		if err := db.First(&user, "email = ?", req.Email).Error; err != nil {
			http.Error(w, "Invalid credentials", http.StatusUnauthorized)
			return
		}

		if !user.CheckPassword(req.Password) {
			http.Error(w, "Invalid credentials", http.StatusUnauthorized)
			return
		}

		token, err := util.GenerateJWT(&user)
		if err != nil {
			http.Error(w, "Could not generate token", http.StatusInternalServerError)
			return
		}

		// N√£o retornar a senha e inicializar Projects como array vazio
		user.Password = ""
		if user.Projects == nil {
			user.Projects = make([]models.Project, 0)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(AuthResponse{
			Message:     "Logged in successfully",
			Token:       token,
			User:        &user,
			ForgeAPIKey: user.ForgeAPIKey,
		})
	}
}