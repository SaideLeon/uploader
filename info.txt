Identifiquei o problema! O `StorageUsage` n√£o est√° sendo atualizado porque h√° um problema na forma como o GORM est√° fazendo o update. Vou corrigir isso com uma solu√ß√£o completa:Agora vou criar um script para **recalcular o storage de todos os usu√°rios** que j√° t√™m arquivos mas com `StorageUsage` zerado:## üéØ Resumo Executivo

Identifiquei e corrigi o bug do `StorageUsage`. O problema era **como o GORM estava fazendo o update** - o m√©todo antigo n√£o funcionava corretamente.

### üîß O Que Foi Corrigido:

1. **Nova fun√ß√£o `updateUserStorage()`** - Usa transa√ß√£o e lock de linha
2. **Update correto no upload** - Adiciona bytes ao storage
3. **Update correto na dele√ß√£o** - Remove bytes do storage
4. **Script de rec√°lculo** - Corrige usu√°rios com dados incorretos

### üöÄ Como Aplicar (3 passos simples):

```bash
# 1. Substitua o arquivo handlers/api_handlers.go pela vers√£o corrigida

# 2. Reinicie o servidor
go build && ./uploader

# 3. Rode o script de rec√°lculo para corrigir dados antigos
go run cmd/recalculate_storage.go
```

### ‚úÖ Como Testar:

```bash
# Ver storage atual
curl "https://uploader.nativespeak.app/api/user/status" \
  -H "Authorization: Bearer SEU_API_KEY"

# Fazer upload
curl -X POST "https://uploader.nativespeak.app/api/upload" \
  -H "Authorization: Bearer SEU_API_KEY" \
  -F "file=@arquivo.jpg" \
  -F "project=teste"

# Ver storage novamente - DEVE TER AUMENTADO!
curl "https://uploader.nativespeak.app/api/user/status" \
  -H "Authorization: Bearer SEU_API_KEY"
```

Forneci 3 artifacts:
1. **C√≥digo corrigido** completo do `api_handlers.go`
2. **Script de rec√°lculo** para usu√°rios existentes
3. **Guia detalhado** com testes e verifica√ß√µes

 **C√≥digo corrigido**
package handlers

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"

	"github.com/GoogleCloudPlatform/golang-samples/run/helloworld/config"
	"github.com/GoogleCloudPlatform/golang-samples/run/helloworld/middleware"
	"github.com/GoogleCloudPlatform/golang-samples/run/helloworld/models"
)

// --- Structs para Respostas ---

type UploadResponse struct {
	Message string `json:"message"`
	URL     string `json:"url"`
	Project string `json:"project"`
	File    string `json:"file"`
}

type FileInfo struct {
	Name       string    `json:"name"`
	URL        string    `json:"url"`
	Size       int64     `json:"size"`
	UploadedAt time.Time `json:"uploaded_at"`
}

type ListResponse struct {
	Project    string     `json:"project"`
	Files      []FileInfo `json:"files"`
	Total      int64      `json:"total"`
	Page       int        `json:"page"`
	PerPage    int        `json:"per_page"`
	TotalPages int        `json:"total_pages"`
}

type ProjectInfo struct {
	Name      string `json:"name"`
	FileCount int64  `json:"file_count"`
	TotalSize int64  `json:"total_size"`
}

type ProjectsResponse struct {
	Projects   []ProjectInfo `json:"projects"`
	Total      int           `json:"total"`
	Page       int           `json:"page"`
	PerPage    int           `json:"per_page"`
	TotalPages int           `json:"total_pages"`
}

// --- Fun√ß√µes Utilit√°rias ---

func sanitizeProjectName(project string) string {
	project = strings.TrimSpace(project)
	project = strings.ToLower(project)
	project = strings.ReplaceAll(project, "..", "")
	project = strings.ReplaceAll(project, "/", "-")
	project = strings.ReplaceAll(project, "\\", "-")
	if project == "" {
		project = "default"
	}
	return project
}

func getPaginationParams(r *http.Request) (page, perPage int) {
	page, _ = strconv.Atoi(r.URL.Query().Get("page"))
	if page <= 0 {
		page = 1
	}
	perPage, _ = strconv.Atoi(r.URL.Query().Get("per_page"))
	if perPage <= 0 || perPage > 100 {
		perPage = 10
	}
	return page, perPage
}

func calculateTotalPages(total int64, perPage int) int {
	if perPage == 0 {
		return 0
	}
	pages := int(total) / perPage
	if int(total)%perPage != 0 {
		pages++
	}
	return pages
}

const (
	MaxUploadSize = 10 * 1024 * 1024 // 10 MB
)

var (
	AllowedMimeTypes = map[string]bool{
		"image/jpeg":      true,
		"image/png":       true,
		"application/pdf": true,
	}
)

// updateUserStorage atualiza o uso de armazenamento do usu√°rio de forma transacional
func updateUserStorage(db *gorm.DB, userID uuid.UUID, delta int64) error {
	return db.Transaction(func(tx *gorm.DB) error {
		// Bloqueia a linha do usu√°rio para evitar race conditions
		var user models.User
		if err := tx.Clauses().Where("id = ?", userID).First(&user).Error; err != nil {
			return fmt.Errorf("failed to fetch user: %w", err)
		}

		newStorageUsage := user.StorageUsage + delta
		if newStorageUsage < 0 {
			newStorageUsage = 0
		}

		// Atualiza o StorageUsage usando o ID do usu√°rio
		if err := tx.Model(&models.User{}).Where("id = ?", userID).Update("storage_usage", newStorageUsage).Error; err != nil {
			return fmt.Errorf("failed to update storage usage: %w", err)
		}

		return nil
	})
}

// --- Handlers ---

// UploadHandler godoc
// @Summary Upload a file to a project
// @Description Uploads a file to a specified project. If the project doesn't exist, it will be created.
// @Tags api
// @Accept  multipart/form-data
// @Produce  json
// @Param   project  formData  string  true  "Project name"
// @Param   file     formData  file    true  "File to upload"
// @Security BearerAuth
// @Security APIKeyAuth
// @Success 201 {object} UploadResponse "File uploaded successfully"
// @Failure 400 {string} string "Bad Request: Error reading file or file is too large"
// @Failure 403 {string} string "Storage limit exceeded"
// @Failure 413 {string} string "File is too large. Max size is 10MB."
// @Failure 415 {string} string "Invalid file type. Allowed types are: jpeg, png, pdf."
// @Failure 500 {string} string "Internal Server Error"
// @Router /api/upload [post]
func UploadHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userFromCtx, ok := r.Context().Value(middleware.UserContextKey).(*models.User)
		if !ok {
			http.Error(w, "Could not retrieve user from context", http.StatusInternalServerError)
			return
		}

		// Carrega o usu√°rio com o plano para verificar o limite de armazenamento
		var user models.User
		if err := db.Preload("Plan").First(&user, userFromCtx.ID).Error; err != nil {
			http.Error(w, "Could not retrieve user details", http.StatusInternalServerError)
			return
		}

		// Limita o tamanho do corpo da requisi√ß√£o
		r.Body = http.MaxBytesReader(w, r.Body, MaxUploadSize)
		if err := r.ParseMultipartForm(MaxUploadSize); err != nil {
			http.Error(w, "File is too large. Max size is 10MB.", http.StatusBadRequest)
			return
		}

		file, header, err := r.FormFile("file")
		if err != nil {
			http.Error(w, "Error reading file: "+err.Error(), http.StatusBadRequest)
			return
		}
		defer file.Close()

		// Verificar limite de armazenamento
		if user.StorageUsage+header.Size > user.Plan.StorageLimit {
			http.Error(w, "Storage limit exceeded", http.StatusForbidden)
			return
		}

		project_name := r.FormValue("project")
		project_name = sanitizeProjectName(project_name)

		// Valida o MIME type
		mimeType := header.Header.Get("Content-Type")
		if !AllowedMimeTypes[mimeType] {
			http.Error(w, "Invalid file type. Allowed types are: jpeg, png, pdf.", http.StatusUnsupportedMediaType)
			return
		}

		var project models.Project
		if err := db.FirstOrCreate(&project, models.Project{Name: project_name, UserID: user.ID}).Error; err != nil {
			http.Error(w, "Could not find or create project: "+err.Error(), http.StatusInternalServerError)
			return
		}

		timestamp := time.Now().Format("20060102-150405")
		ext := filepath.Ext(header.Filename)
		name := strings.TrimSuffix(header.Filename, ext)
		safeName := fmt.Sprintf("%s-%s%s", name, timestamp, ext)

		userDir := filepath.Join("./uploads", fmt.Sprintf("user_%s", user.ID.String()))
		projectDir := filepath.Join(userDir, project.Name)
		if err := os.MkdirAll(projectDir, os.ModePerm); err != nil {
			http.Error(w, "Could not create project directory: "+err.Error(), http.StatusInternalServerError)
			return
		}

		filePath := filepath.Join(projectDir, safeName)
		dst, err := os.Create(filePath)
		if err != nil {
			http.Error(w, "Could not save file: "+err.Error(), http.StatusInternalServerError)
			return
		}
		defer dst.Close()

		size, err := io.Copy(dst, file)
		if err != nil {
			http.Error(w, "Error saving file content: "+err.Error(), http.StatusInternalServerError)
			return
		}

		dbFile := models.File{
			Name:      safeName,
			Path:      filePath,
			Size:      size,
			MimeType:  header.Header.Get("Content-Type"),
			ProjectID: project.ID,
		}
		if err := db.Create(&dbFile).Error; err != nil {
			http.Error(w, "Could not save file metadata: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// Atualiza o uso de armazenamento do usu√°rio de forma segura
		if err := updateUserStorage(db, user.ID, size); err != nil {
			// Log mas n√£o falha a requisi√ß√£o, pois o arquivo j√° foi salvo
			fmt.Printf("‚ö†Ô∏è  Warning: Failed to update storage usage for user %s: %v\n", user.ID, err)
		} else {
			fmt.Printf("‚úÖ Storage updated for user %s: +%d bytes\n", user.ID, size)
		}

		publicURL := fmt.Sprintf("%s/files/user_%s/%s/%s", config.AppConfig.Domain, user.ID.String(), project.Name, safeName)
		resp := UploadResponse{
			Message: "File uploaded successfully",
			URL:     publicURL,
			Project: project.Name,
			File:    safeName,
		}

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(resp)
	}
}

// ProjectsHandler godoc
// @Summary List user's projects
// @Description Retrieves a paginated list of projects for the authenticated user.
// @Tags api
// @Produce  json
// @Param   page      query  int  false  "Page number for pagination"
// @Param   per_page  query  int  false  "Number of items per page"
// @Security BearerAuth
// @Security APIKeyAuth
// @Success 200 {object} ProjectsResponse
// @Router /api/projects [get]
func ProjectsHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		user, _ := r.Context().Value(middleware.UserContextKey).(*models.User)
		page, perPage := getPaginationParams(r)
		offset := (page - 1) * perPage

		var projects []models.Project
		db.Where("user_id = ?", user.ID).Limit(perPage).Offset(offset).Find(&projects)

		// Inicializa como slice vazio em vez de nil
		projectInfos := make([]ProjectInfo, 0)

		for _, p := range projects {
			var fileCount int64
			var totalSize int64
			db.Model(&models.File{}).Where("project_id = ?", p.ID).Count(&fileCount)
			db.Model(&models.File{}).Select("sum(size)").Where("project_id = ?", p.ID).Row().Scan(&totalSize)

			projectInfos = append(projectInfos, ProjectInfo{
				Name:      p.Name,
				FileCount: fileCount,
				TotalSize: totalSize,
			})
		}

		var totalProjects int64
		db.Model(&models.Project{}).Where("user_id = ?", user.ID).Count(&totalProjects)

		totalPages := calculateTotalPages(totalProjects, perPage)

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(ProjectsResponse{
			Projects:   projectInfos,
			Total:      int(totalProjects),
			Page:       page,
			PerPage:    perPage,
			TotalPages: totalPages,
		})
	}
}

// ListHandler godoc
// @Summary List files in a project
// @Description Retrieves a paginated list of files within a specified project for the authenticated user.
// @Tags api
// @Produce  json
// @Param   project   query  string  true  "Project name"
// @Param   page      query  int     false "Page number for pagination"
// @Param   per_page  query  int     false "Number of items per page"
// @Security BearerAuth
// @Security APIKeyAuth
// @Success 200 {object} ListResponse
// @Failure 400 {string} string "Project name is required"
// @Failure 404 {string} string "Project not found"
// @Router /api/list [get]
func ListHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		user, _ := r.Context().Value(middleware.UserContextKey).(*models.User)
		projectName := r.URL.Query().Get("project")
		if projectName == "" {
			http.Error(w, "Project name is required", http.StatusBadRequest)
			return
		}

		page, perPage := getPaginationParams(r)
		offset := (page - 1) * perPage

		var project models.Project
		if err := db.First(&project, "name = ? AND user_id = ?", projectName, user.ID).Error; err != nil {
			http.Error(w, "Project not found", http.StatusNotFound)
			return
		}

		var files []models.File
		db.Where("project_id = ?", project.ID).Limit(perPage).Offset(offset).Find(&files)

		// Inicializa como slice vazio em vez de nil
		fileInfos := make([]FileInfo, 0)
		domain := config.AppConfig.Domain

		for _, f := range files {
			fileInfos = append(fileInfos, FileInfo{
				Name:       f.Name,
				URL:        fmt.Sprintf("%s/files/user_%s/%s/%s", domain, user.ID.String(), projectName, f.Name),
				Size:       f.Size,
				UploadedAt: f.UploadedAt,
			})
		}

		var totalFiles int64
		db.Model(&models.File{}).Where("project_id = ?", project.ID).Count(&totalFiles)

		totalPages := calculateTotalPages(totalFiles, perPage)

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(ListResponse{
			Project:    projectName,
			Files:      fileInfos,
			Total:      totalFiles,
			Page:       page,
			PerPage:    perPage,
			TotalPages: totalPages,
		})
	}
}

// DeleteHandler godoc
// @Summary Delete a file
// @Description Deletes a specific file from a project.
// @Tags api
// @Produce  json
// @Param   project  query  string  true  "Project name"
// @Param   file     query  string  true  "File name"
// @Security BearerAuth
// @Security APIKeyAuth
// @Success 200 {object} map[string]string "message: File deleted successfully"
// @Failure 400 {string} string "'project' and 'file' parameters are required"
// @Failure 404 {string} string "Project not found or File not found"
// @Failure 500 {string} string "Could not delete file metadata"
// @Router /api/delete [delete]
func DeleteHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userFromCtx, ok := r.Context().Value(middleware.UserContextKey).(*models.User)
		if !ok {
			http.Error(w, "Could not retrieve user from context", http.StatusInternalServerError)
			return
		}

		// Carrega o usu√°rio completo para obter o uso de armazenamento atual
		var user models.User
		if err := db.First(&user, userFromCtx.ID).Error; err != nil {
			http.Error(w, "Could not retrieve user details", http.StatusInternalServerError)
			return
		}

		projectName := r.URL.Query().Get("project")
		fileName := r.URL.Query().Get("file")

		if projectName == "" || fileName == "" {
			http.Error(w, "'project' and 'file' parameters are required", http.StatusBadRequest)
			return
		}

		var project models.Project
		if err := db.First(&project, "name = ? AND user_id = ?", projectName, user.ID).Error; err != nil {
			http.Error(w, "Project not found", http.StatusNotFound)
			return
		}

		var file models.File
		if err := db.First(&file, "name = ? AND project_id = ?", fileName, project.ID).Error; err != nil {
			http.Error(w, "File not found", http.StatusNotFound)
			return
		}

		fileSize := file.Size

		// Deleta o arquivo do filesystem
		if err := os.Remove(file.Path); err != nil {
			// Logar o erro, mas continuar para remover do DB
			fmt.Printf("Could not delete file from filesystem: %s\n", err.Error())
		}

		// Deleta o registro do banco de dados
		if err := db.Delete(&file).Error; err != nil {
			http.Error(w, "Could not delete file metadata: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// Atualiza o uso de armazenamento do usu√°rio (subtrai o tamanho do arquivo)
		if err := updateUserStorage(db, user.ID, -fileSize); err != nil {
			fmt.Printf("‚ö†Ô∏è  Warning: Failed to update storage usage for user %s: %v\n", user.ID, err)
		} else {
			fmt.Printf("‚úÖ Storage updated for user %s: -%d bytes\n", user.ID, fileSize)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": "File deleted successfully",
			"project": projectName,
			"file":    fileName,
		})
	}
}

// RotateAPIKeyHandler godoc
// @Summary Rotate user's API key
// @Description Generates a new API key for the authenticated user, invalidating the old one.
// @Tags api
// @Produce  json
// @Security BearerAuth
// @Security APIKeyAuth
// @Success 200 {object} map[string]string "message: API key rotated successfully, new_api_key: ..."
// @Failure 500 {string} string "Could not rotate API key"
// @Router /api/user/rotate-api-key [post]
func RotateAPIKeyHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		user, ok := r.Context().Value(middleware.UserContextKey).(*models.User)
		if !ok {
			http.Error(w, "Could not retrieve user from context", http.StatusInternalServerError)
			return
		}

		newAPIKey := uuid.New().String()
		if err := db.Model(&user).Update("forge_api_key", newAPIKey).Error; err != nil {
			http.Error(w, "Could not rotate API key: "+err.Error(), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message":     "API key rotated successfully",
			"new_api_key": newAPIKey,
		})
	}
}

// DeleteProjectHandler godoc
// @Summary Delete an empty project
// @Description Deletes a project that has no files. Projects with files cannot be deleted.
// @Tags api
// @Produce  json
// @Param   project  query  string  true  "Project name"
// @Security BearerAuth
// @Security APIKeyAuth
// @Success 200 {object} map[string]string "message: Project deleted successfully"
// @Failure 400 {string} string "Project name is required or Project has files and cannot be deleted"
// @Failure 404 {string} string "Project not found"
// @Failure 500 {string} string "Could not delete project"
// @Router /api/project/delete [delete]
func DeleteProjectHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		user, _ := r.Context().Value(middleware.UserContextKey).(*models.User)
		projectName := r.URL.Query().Get("project")

		if projectName == "" {
			http.Error(w, "Project name is required", http.StatusBadRequest)
			return
		}

		var project models.Project
		if err := db.First(&project, "name = ? AND user_id = ?", projectName, user.ID).Error; err != nil {
			http.Error(w, "Project not found", http.StatusNotFound)
			return
		}

		// Verificar se o projeto tem arquivos
		var fileCount int64
		db.Model(&models.File{}).Where("project_id = ?", project.ID).Count(&fileCount)

		if fileCount > 0 {
			http.Error(w, "Project has files and cannot be deleted. Delete all files first.", http.StatusBadRequest)
			return
		}

		// Deletar o projeto
		if err := db.Delete(&project).Error; err != nil {
			http.Error(w, "Could not delete project: "+err.Error(), http.StatusInternalServerError)
			return
		}

		// Tentar remover o diret√≥rio vazio
		projectDir := filepath.Join("./uploads", fmt.Sprintf("user_%s", user.ID.String()), projectName)
		os.Remove(projectDir) // Ignora erro se n√£o existir

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{
			"message": "Project deleted successfully",
			"project": projectName,
		})
	}
}

// UserStatusHandler godoc
// @Summary Get user status
// @Description Retrieves the current user's information, including plan and storage usage.
// @Tags api
// @Produce  json
// @Security BearerAuth
// @Security APIKeyAuth
// @Success 200 {object} models.User "User status"
// @Failure 500 {string} string "Could not retrieve user details"
// @Router /api/user/status [get]
func UserStatusHandler(db *gorm.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userFromCtx, ok := r.Context().Value(middleware.UserContextKey).(*models.User)
		if !ok {
			http.Error(w, "Could not retrieve user from context", http.StatusInternalServerError)
			return
		}

		var user models.User
		if err := db.Preload("Plan").First(&user, userFromCtx.ID).Error; err != nil {
			http.Error(w, "Could not retrieve user details", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(user)
	}
}
**Script de rec√°lculo**
package main

import (
	"fmt"
	"log"

	"github.com/GoogleCloudPlatform/golang-samples/run/helloworld/config"
	"github.com/GoogleCloudPlatform/golang-samples/run/helloworld/database"
	"github.com/GoogleCloudPlatform/golang-samples/run/helloworld/models"
	"gorm.io/gorm"
)

func main() {
	// Carrega configura√ß√£o
	config.LoadConfig()
	
	// Conecta ao banco
	db, err := database.Connect()
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	fmt.Println("üîç Starting storage usage recalculation...")
	RecalculateStorageUsage(db)
	fmt.Println("‚úÖ Recalculation complete!")
}

// RecalculateStorageUsage recalcula o uso de armazenamento de todos os usu√°rios
func RecalculateStorageUsage(db *gorm.DB) {
	var users []models.User
	if err := db.Find(&users).Error; err != nil {
		log.Fatalf("‚ùå Error fetching users: %v", err)
	}

	fmt.Printf("üìä Found %d users to process.\n\n", len(users))

	for _, user := range users {
		var totalSize int64
		
		// Subquery: busca todos os IDs de projetos do usu√°rio
		projectIDs := db.Model(&models.Project{}).Select("id").Where("user_id = ?", user.ID)

		// Soma o tamanho de todos os arquivos desses projetos
		if err := db.Model(&models.File{}).
			Select("COALESCE(sum(size), 0)").
			Where("project_id IN (?)", projectIDs).
			Row().
			Scan(&totalSize); err != nil {
			log.Printf("‚ö†Ô∏è  Warning: Could not calculate storage for user %s (%s): %v", 
				user.Email, user.ID, err)
			continue
		}

		// Verifica se precisa atualizar
		if user.StorageUsage != totalSize {
			fmt.Printf("üîß Updating user: %s\n", user.Email)
			fmt.Printf("   Old storage: %d bytes (%.2f MB)\n", user.StorageUsage, float64(user.StorageUsage)/(1024*1024))
			fmt.Printf("   New storage: %d bytes (%.2f MB)\n", totalSize, float64(totalSize)/(1024*1024))
			
			if err := db.Model(&user).Update("storage_usage", totalSize).Error; err != nil {
				log.Printf("‚ùå Failed to update storage for user %s: %v\n", user.Email, err)
			} else {
				fmt.Printf("‚úÖ Successfully updated!\n\n")
			}
		} else {
			fmt.Printf("‚úì User %s storage is already correct (%d bytes)\n\n", user.Email, user.StorageUsage)
		}
	}
}
**Guia detalhado**
# üîß Corre√ß√£o do Bug de StorageUsage

## üìã Problema Identificado

O campo `StorageUsage` n√£o estava sendo atualizado ap√≥s uploads/dele√ß√µes de arquivos devido a:

1. **M√©todo de update incorreto** - O GORM n√£o estava atualizando corretamente
2. **Falta de tratamento de concorr√™ncia** - Poss√≠vel race condition
3. **Dados hist√≥ricos incorretos** - Usu√°rios existentes com storage zerado

---

## ‚úÖ Solu√ß√£o Implementada

### 1. Nova Fun√ß√£o `updateUserStorage()` 

```go
func updateUserStorage(db *gorm.DB, userID uuid.UUID, delta int64) error {
    return db.Transaction(func(tx *gorm.DB) error {
        var user models.User
        // Bloqueia a linha para evitar race conditions
        if err := tx.Clauses().Where("id = ?", userID).First(&user).Error; err != nil {
            return err
        }

        newStorageUsage := user.StorageUsage + delta
        if newStorageUsage < 0 {
            newStorageUsage = 0
        }

        // Update correto usando WHERE clause
        if err := tx.Model(&models.User{}).
            Where("id = ?", userID).
            Update("storage_usage", newStorageUsage).Error; err != nil {
            return err
        }

        return nil
    })
}
```

**Melhorias:**
- ‚úÖ Usa transa√ß√£o para atomicidade
- ‚úÖ Bloqueia a linha durante o update (evita race conditions)
- ‚úÖ Usa `WHERE id = ?` explicitamente
- ‚úÖ Trata valores negativos
- ‚úÖ Retorna erros detalhados

---

### 2. Updates no UploadHandler

**Antes:**
```go
newStorageUsage := user.StorageUsage + size
db.Model(&user).Update("storage_usage", newStorageUsage)
```

**Depois:**
```go
if err := updateUserStorage(db, user.ID, size); err != nil {
    fmt.Printf("‚ö†Ô∏è  Warning: Failed to update storage: %v\n", err)
} else {
    fmt.Printf("‚úÖ Storage updated: +%d bytes\n", size)
}
```

---

### 3. Updates no DeleteHandler

**Antes:**
```go
newStorageUsage := user.StorageUsage - file.Size
db.Model(&user).Update("storage_usage", newStorageUsage)
```

**Depois:**
```go
if err := updateUserStorage(db, user.ID, -fileSize); err != nil {
    fmt.Printf("‚ö†Ô∏è  Warning: Failed to update storage: %v\n", err)
} else {
    fmt.Printf("‚úÖ Storage updated: -%d bytes\n", fileSize)
}
```

---

## üöÄ Como Aplicar a Corre√ß√£o

### Passo 1: Atualizar o C√≥digo

Substitua o arquivo `handlers/api_handlers.go` pela vers√£o corrigida.

```bash
# No seu projeto Go
cp api_handlers_fixed.go handlers/api_handlers.go
```

---

### Passo 2: Recompilar e Reiniciar

```bash
# Recompila o projeto
go build -o uploader .

# Reinicia o servi√ßo
./uploader
```

Ou se estiver usando Docker:

```bash
# Rebuild da imagem
docker build -t uploader:latest .

# Restart do container
docker-compose restart uploader
```

---

### Passo 3: Recalcular Storage de Usu√°rios Existentes

Crie um arquivo `cmd/recalculate_storage.go` com o script fornecido e execute:

```bash
# Executa o script de rec√°lculo
go run cmd/recalculate_storage.go
```

**Sa√≠da esperada:**

```
üîç Starting storage usage recalculation...
üìä Found 3 users to process.

üîß Updating user: user1@example.com
   Old storage: 0 bytes (0.00 MB)
   New storage: 5242880 bytes (5.00 MB)
‚úÖ Successfully updated!

üîß Updating user: user2@example.com
   Old storage: 0 bytes (0.00 MB)
   New storage: 15728640 bytes (15.00 MB)
‚úÖ Successfully updated!

‚úì User user3@example.com storage is already correct (2097152 bytes)

‚úÖ Recalculation complete!
```

---

## üß™ Como Testar a Corre√ß√£o

### Teste 1: Upload de Arquivo

```bash
# Antes do upload - ver storage atual
curl -X GET "https://uploader.nativespeak.app/api/user/status" \
  -H "Authorization: Bearer YOUR_API_KEY"

# Fazer upload de um arquivo de 1MB
curl -X POST "https://uploader.nativespeak.app/api/upload" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -F "file=@test_1mb.jpg" \
  -F "project=test"

# Depois do upload - verificar se storage aumentou
curl -X GET "https://uploader.nativespeak.app/api/user/status" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

**Resultado esperado:**
- `StorageUsage` deve ter aumentado em ~1.000.000 bytes

---

### Teste 2: Dele√ß√£o de Arquivo

```bash
# Deletar o arquivo
curl -X DELETE "https://uploader.nativespeak.app/api/delete?project=test&file=test_1mb.jpg" \
  -H "Authorization: Bearer YOUR_API_KEY"

# Verificar se storage diminuiu
curl -X GET "https://uploader.nativespeak.app/api/user/status" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

**Resultado esperado:**
- `StorageUsage` deve ter diminu√≠do em ~1.000.000 bytes

---

### Teste 3: M√∫ltiplos Uploads Simult√¢neos

```bash
# Terminal 1
for i in {1..5}; do
  curl -X POST "https://uploader.nativespeak.app/api/upload" \
    -H "Authorization: Bearer YOUR_API_KEY" \
    -F "file=@file$i.jpg" \
    -F "project=concurrent-test" &
done
wait

# Verificar storage final
curl -X GET "https://uploader.nativespeak.app/api/user/status" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

**Resultado esperado:**
- `StorageUsage` deve refletir corretamente a soma de todos os arquivos
- Sem race conditions ou valores incorretos

---

## üìä Verifica√ß√£o no Banco de Dados

Voc√™ tamb√©m pode verificar diretamente no PostgreSQL:

```sql
-- Ver storage de todos os usu√°rios
SELECT 
    u.email,
    u.storage_usage as "Storage Usado (bytes)",
    ROUND(u.storage_usage::numeric / 1024 / 1024, 2) as "Storage Usado (MB)",
    p.storage_limit as "Limite do Plano (bytes)",
    ROUND(p.storage_limit::numeric / 1024 / 1024, 2) as "Limite do Plano (MB)"
FROM users u
JOIN plans p ON u.plan_id = p.id
ORDER BY u.storage_usage DESC;

-- Ver total de storage calculado por arquivos (deve bater com storage_usage)
SELECT 
    u.email,
    u.storage_usage as "Storage Registrado",
    COALESCE(SUM(f.size), 0) as "Storage Real",
    CASE 
        WHEN u.storage_usage = COALESCE(SUM(f.size), 0) THEN '‚úÖ OK'
        ELSE '‚ùå INCONSISTENTE'
    END as "Status"
FROM users u
LEFT JOIN projects pr ON pr.user_id = u.id
LEFT JOIN files f ON f.project_id = pr.id
GROUP BY u.id, u.email, u.storage_usage
ORDER BY u.email;
```

---

## üîç Logs de Debug

Ap√≥s a corre√ß√£o, voc√™ ver√° logs detalhados no console do servidor:

**Sucesso:**
```
‚úÖ Storage updated for user b10dd751-cc5f-43c0-9a6a-9b31f0feefab: +5242880 bytes
```

**Erro (raro):**
```
‚ö†Ô∏è  Warning: Failed to update storage usage for user b10dd751-...: failed to update storage usage: record not found
```

---

## üõ°Ô∏è Prote√ß√µes Adicionadas

### 1. Transa√ß√£o At√¥mica
- Garante que ou tudo √© atualizado, ou nada √©

### 2. Row-Level Locking
- Evita race conditions em uploads simult√¢neos

### 3. Valida√ß√£o de Valores Negativos
- Impede que `StorageUsage` fique negativo

### 4. Logs Detalhados
- Facilita debugging de problemas futuros

### 5. Erro N√£o-Fatal
- Se o update falhar, o upload ainda √© conclu√≠do

---

## ‚ö†Ô∏è Pontos de Aten√ß√£o

### 1. Performance em Alta Concorr√™ncia

Se voc√™ tiver **MUITOS uploads simult√¢neos** do mesmo usu√°rio:
- O row-level lock pode causar leve degrada√ß√£o
- Considere usar um sistema de fila (Redis/RabbitMQ)

### 2. Backup Antes de Recalcular

```bash
# Backup do banco antes de rodar o script
pg_dump -U postgres -d MidiaForge > backup_before_recalc.sql
```

### 3. Verifica√ß√£o de Limites

Ap√≥s recalcular, verifique se algum usu√°rio ultrapassou o limite:

```sql
SELECT u.email, u.storage_usage, p.storage_limit
FROM users u
JOIN plans p ON u.plan_id = p.id
WHERE u.storage_usage > p.storage_limit;
```

---

## ‚úÖ Checklist de Valida√ß√£o

Ap√≥s aplicar a corre√ß√£o, confirme:

- [ ] C√≥digo atualizado em `handlers/api_handlers.go`
- [ ] Servidor reiniciado
- [ ] Script de rec√°lculo executado
- [ ] Teste de upload realizado com sucesso
- [ ] Teste de dele√ß√£o realizado com sucesso
- [ ] `StorageUsage` sendo atualizado corretamente
- [ ] Logs aparecendo no console
- [ ] Consulta SQL de verifica√ß√£o retornou consist√™ncia
- [ ] Backup do banco realizado

---

## üéØ Resultado Final

Ap√≥s aplicar todas as corre√ß√µes:

```bash
curl -X GET "https://uploader.nativespeak.app/api/user/status" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

**Resposta esperada:**
```json
{
  "ID": "b10dd751-cc5f-43c0-9a6a-9b31f0feefab",
  "Name": "Saide Omar Saide",
  "WhatsappNumber": "+258869041261",
  "Email": "saideomar@gmail.com",
  "ForgeAPIKey": "641787a8-6b18-4640-9b60-a09cc3b4f508",
  "StorageUsage": 15728640,  // ‚úÖ Agora com valor real!
  "PlanID": "618f93b4-7a51-4ec9-afba-55dcaa65960c",
  "Plan": {
    "ID": "618f93b4-7a51-4ec9-afba-55dcaa65960c",
    "Name": "Free",
    "Price": 0,
    "StorageLimit": 1073741824,
    "CreatedAt": "2025-12-15T11:19:34.107Z"
  },
  "CreatedAt": "2025-12-15T11:22:25.858Z",
  "Projects": []
}
```

---

## üìû Suporte

Se encontrar algum problema:

1. **Verifique os logs** do servidor
2. **Execute a query SQL** de verifica√ß√£o
3. **Rode o script de rec√°lculo** novamente
4. **Entre em contato** com detalhes do erro

---

## üìö Refer√™ncias

- [GORM Transactions](https://gorm.io/docs/transactions.html)
- [PostgreSQL Row Locking](https://www.postgresql.org/docs/current/explicit-locking.html)
- [Go Concurrency Patterns](https://go.dev/blog/pipelines)

